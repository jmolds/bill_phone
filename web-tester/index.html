<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bill's Phone WebRTC Tester</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #121212;
            color: white;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
        }
        .status-box {
            background-color: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .video-container {
            background-color: #2C3E50;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
            position: relative;
        }
        #remoteVideo {
            width: 100%;
            background: #000;
            border-radius: 10px;
        }
        #localVideo {
            position: absolute;
            width: 120px;
            bottom: 10px;
            right: 10px;
            border: 2px solid white;
            border-radius: 5px;
            background: #333;
        }
        .button {
            display: block;
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 50px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .call-button {
            background-color: #4CAF50;
        }
        .end-button {
            background-color: #F44336;
        }
        .log-container {
            background-color: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            margin-top: 20px;
        }
        .connection-field {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="text"] {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: none;
            background-color: rgba(255,255,255,0.2);
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bill's Phone WebRTC Tester</h1>
        
        <div class="connection-field">
            <label for="serverUrl">Signaling Server URL:</label>
            <input type="text" id="serverUrl" value="http://143.198.180.248:3000">
        </div>
        
        <div class="connection-field">
            <label for="deviceRole">Select Role:</label>
            <select id="deviceRole" onchange="updateDeviceId()">
                <option value="bills-iphone">Bill's Phone</option>
                <option value="family-caller">Family Caller</option>
            </select>
        </div>
        
        <div class="connection-field">
            <label for="targetId">Target to Call:</label>
            <select id="targetId">
                <option value="bills-iphone">Bill's Phone</option>
                <option value="family-caller">Family Caller</option>
            </select>
        </div>
        
        <div class="status-box">
            <p>Connection Status: <span id="connectionStatus">Disconnected</span></p>
            <p>Device ID: <span id="deviceId">Not assigned</span></p>
            <p>Call Status: <span id="callStatus">Idle</span></p>
        </div>
        
        <div class="video-container">
            <video id="remoteVideo" autoplay playsinline></video>
            <video id="localVideo" autoplay playsinline muted></video>
        </div>
        
        <button id="callButton" class="button call-button">Start Call</button>
        <button id="endButton" class="button end-button" style="display: none;">End Call</button>

        <!-- --- Family User Profile API Tester --- -->
        <hr style="margin:32px 0; border:1px solid #444;">
        <!-- <div class="profile-api-section">
            <h2>Family User Profile API Tester</h2>
            ... (HTML form hidden in favor of React UI) ...
        </div> -->
        <!-- --- End Family User Profile API Tester --- -->

        <!-- React-based Profile Tester (built with main.jsx) -->
        <div id="react-root"></div>
        <script src="main.js"></script>
        <!-- End React-based Profile Tester -->

        <div class="log-container" id="logContainer">
            <div>Logs will appear here...</div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>
    <script>
        // DOM elements
        const serverUrlInput = document.getElementById('serverUrl');
        const deviceRoleInput = document.getElementById('deviceRole');
        const deviceIdEl = document.getElementById('deviceId');
        const targetIdInput = document.getElementById('targetId');
        const callButton = document.getElementById('callButton');
        const endButton = document.getElementById('endButton');
        const connectionStatusEl = document.getElementById('connectionStatus');
        const callStatusEl = document.getElementById('callStatus');
        const logContainer = document.getElementById('logContainer');

        // WebRTC variables
        let socket;
        let deviceId = null;
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let isConnected = false;
        let isInCall = false;
        
        // Connection backoff parameters to avoid rate limiting
        let connectionAttempts = 0;
        let backoffDelay = 1000; // Start with 1 second
        let maxBackoffDelay = 30000; // Max 30 seconds
        let connectionTimer = null;

        // Log function
        function log(message) {
            const logEntry = document.createElement('div');
            logEntry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(message);
        }

        // Connect to signaling server
        callButton.addEventListener('click', async () => {
            if (!isConnected) {
                connectToSignalingServer();
            } else if (!isInCall) {
                startCall();
            }
        });

        endButton.addEventListener('click', () => {
            endCall();
        });

        async function connectToSignalingServer() {
            const serverUrl = serverUrlInput.value;
            
            log(`Connecting to signaling server: ${serverUrl}`);
            connectionStatusEl.textContent = "Connecting...";
            
            try {
                // Close any existing socket
                if (socket) {
                    socket.close();
                }
                
                // Enhanced socket.io options for better compatibility with server
                const socketOptions = {
                    // Transport configuration - match iOS app's transport priority
                    transports: ['polling', 'websocket'],
                    
                    // Connection settings
                    reconnection: true,
                    reconnectionAttempts: 10,
                    reconnectionDelay: 2000,
                    reconnectionDelayMax: 10000,
                    timeout: 30000,
                    
                    // Security settings - match iOS app
                    secure: serverUrl.startsWith('https'),
                    rejectUnauthorized: false,
                    
                    // Force new connection to avoid caching issues
                    forceNew: true,
                    
                    // Headers for compatibility with server CORS rules
                    extraHeaders: {
                        'Origin': 'https://api.justinmolds.com',
                        'User-Agent': 'BillsPhone-Web/1.0.0'
                    },
                    
                    // Query parameters for server-side identification
                    query: {
                        deviceId: deviceId, 
                        platform: 'web'
                    },
                    
                    // Other settings from iOS app
                    upgrade: true,
                    rememberUpgrade: false,
                    jsonp: false,
                    withCredentials: true,
                    autoConnect: true
                };
                
                log(`Attempting connection with iOS-compatible options...`);
                socket = io(serverUrl, socketOptions);
                setupSocketEvents();
                
                // Add timeout fallback similar to iOS app
                const connectionTimeout = setTimeout(() => {
                    if (connectionStatusEl.textContent === "Connecting...") {
                        log('Connection timeout - trying polling-only transport');
                        
                        // Disconnect current attempt
                        socket.disconnect();
                        
                        // Try polling-only mode
                        socket = io(serverUrl, {
                            ...socketOptions,
                            transports: ['polling'], // Polling only
                            timeout: 15000
                        });
                        
                        setupSocketEvents();
                    }
                }, 8000);
                
                // Clear timeout on successful connection
                socket.on('connect', () => {
                    clearTimeout(connectionTimeout);
                });
            } catch (error) {
                log(`Connection error: ${error.message || error}`);
                connectionStatusEl.textContent = "Connection Failed";
            }
        }

        function updateDeviceId() {
            const role = document.getElementById('deviceRole').value;
            const targetSelect = document.getElementById('targetId');
            
            // Set my device ID based on role
            deviceId = role;
            deviceIdEl.textContent = role;
            
            // Update target dropdown to exclude my role
            targetSelect.innerHTML = '';
            if (role === 'bills-iphone') {
                targetSelect.innerHTML = '<option value="family-caller">Family Caller</option>';
            } else {
                targetSelect.innerHTML = '<option value="bills-iphone">Bill\'s Phone</option>';
            }
            
            log(`Role changed to: ${role}`);
        }
        
        function setupSocketEvents() {
            socket.on('connect', () => {
                isConnected = true;
                // Override the socket.id with our simple role-based ID
                const role = document.getElementById('deviceRole').value;
                deviceId = role;
                deviceIdEl.textContent = deviceId;
                connectionStatusEl.textContent = 'Connected';
                callButton.textContent = 'Start Call';
                log('Connected to signaling server');
                
                // Register with the server using our simple ID
                setTimeout(() => {
                    socket.emit('register', { deviceId: deviceId });
                    log(`Registered as: ${deviceId}`);
                    
                    // Send a second registration after a short delay (helps with mobile browser issues)
                    setTimeout(() => {
                        socket.emit('register', { deviceId: deviceId });
                        log(`Re-registered as: ${deviceId}`);
                    }, 1000);
                }, 500);
            });

            socket.on('connect_error', (error) => {
                log(`Connection error: ${error.message}`);
                isConnected = false;
                connectionStatusEl.textContent = 'Connection Failed';
            });

            socket.on('disconnect', (reason) => {
                log(`Disconnected: ${reason}`);
                isConnected = false;
                connectionStatusEl.textContent = 'Disconnected';
                
                if (isInCall) {
                    endCall();
                }
            });

            socket.on('incomingCall', async (data) => {
                log(`Incoming call from: ${data.from}`);
                callStatusEl.textContent = 'Incoming Call';
                
                if (confirm(`Incoming call from ${data.from}. Accept?`)) {
                    await setupPeerConnection();
                    await answerCall(data);
                } else {
                    socket.emit('callRejected', { to: data.from });
                }
            });

            socket.on('callAccepted', async (data) => {
                log('Call accepted');
                try {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                    callStatusEl.textContent = 'Connected';
                } catch (error) {
                    log(`Error setting remote description: ${error.message}`);
                }
            });

            socket.on('iceCandidate', async (data) => {
                log(`Received ICE candidate from: ${data.from}`);
                try {
                    if (peerConnection) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    }
                } catch (error) {
                    log(`Error adding ICE candidate: ${error.message}`);
                }
            });

            socket.on('callEnded', (data) => {
                log(`Call ended by: ${data.from}`);
                endCall();
            });

            socket.on('callRejected', (data) => {
                log(`Call rejected by: ${data.from}`);
                endCall();
                alert('Call was rejected');
            });

            socket.on('callError', (data) => {
                log(`Call error: ${data.message}`);
                alert(`Call error: ${data.message}`);
                endCall();
            });
        }
        async function setupPeerConnection() {
            log('Setting up peer connection');
            
            try {
                // Step 1: Request camera and microphone permissions
                log('Requesting camera and microphone permissions...');
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: true,
                    video: true
                });
                
                log(`Media access granted: ${localStream.getTracks().length} tracks`);
                // Log each track type
                localStream.getTracks().forEach(track => {
                    log(`Local track: ${track.kind} (${track.readyState}) - label: ${track.label}`);
                });
                
                // Display local video
                localVideo.srcObject = localStream;
                log('Local video element setup complete');
                
                // Add immediate visual feedback
                localVideo.onloadedmetadata = () => {
                    log('Local video metadata loaded');
                };
                
                // Step 2: Fetch WebRTC configuration from server
                log('Fetching WebRTC configuration from server...');
                let configuration = {
                    iceServers: [
                        // Fallback STUN servers if fetch fails
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };
                
                // Hard-coded fallback TURN server credentials
                // IMPORTANT: These should match the values in your .env file
                const fallbackTurnConfig = {
                    urls: [
                        'turn:143.198.180.248:3478',
                        'turn:143.198.180.248:3478?transport=tcp'
                    ],
                    username: 'webrtcuser8888',
                    credential: 'supersecret8888'
                };
                
                // Get the server URL from the signaling input field
                const serverUrl = serverUrlInput.value;
                const baseUrl = serverUrl.split('/socket.io')[0]; // Remove any socket.io path
                const configUrl = `${baseUrl}/webrtc-config`;
                
                let fetchSuccess = false;
                try {
                    log(`Requesting config from: ${configUrl}`);
                    const fetchOptions = {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'Cache-Control': 'no-cache'
                        },
                        mode: 'cors',
                        credentials: 'omit',
                    };
                    
                    const response = await Promise.race([
                        fetch(configUrl, fetchOptions),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('Fetch timeout')), 5000))
                    ]);
                    
                    if (response.ok) {
                        const config = await response.json();
                        fetchSuccess = true;
                        configuration = config;
                        log('✅ Successfully fetched WebRTC configuration from server');
                        log(`Using ${configuration.iceServers.length} ICE servers from server`);
                        log(`TURN servers: ${JSON.stringify(configuration.iceServers.filter(s => s.urls.toString().includes('turn:')))}`);
                    } else {
                        log(`Failed to fetch WebRTC config: HTTP ${response.status} ${response.statusText}`, 'error');
                    }
                } catch (error) {
                    log(`Error fetching WebRTC configuration: ${error.message}`, 'error');
                }
                
                if (!fetchSuccess) {
                    log('Using fallback TURN configuration', 'warning');
                    // Add fallback TURN server to our configuration
                    configuration.iceServers.push(fallbackTurnConfig);
                    log(`Added fallback TURN server: ${fallbackTurnConfig.urls.join(', ')}`);
                }
                
                peerConnection = new RTCPeerConnection(configuration);
                
                // Add local stream to peer connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
                
                // Handle remote stream with detailed logging
                peerConnection.ontrack = (event) => {
                    log(`Received remote track: ${event.track.kind} (${event.track.readyState})`);
                    log(`Track settings: ${JSON.stringify(event.track.getSettings())}`);
                    
                    if (event.streams && event.streams[0]) {
                        remoteStream = event.streams[0];
                        log(`Got remote stream with ${remoteStream.getTracks().length} tracks`);
                        remoteStream.getTracks().forEach(track => {
                            log(`Remote track: ${track.kind} (${track.readyState}) - active: ${track.enabled}`);
                        });
                        
                        remoteVideo.srcObject = remoteStream;
                        log('Remote video element srcObject set');
                        
                        // Setup additional event handlers
                        remoteVideo.onloadedmetadata = () => {
                            log('Remote video metadata loaded');
                            // Try to play the video
                            remoteVideo.play().then(() => {
                                log('Remote video playing successfully');
                            }).catch(err => {
                                log(`Remote video play failed: ${err}`);
                            });
                        };
                        
                        remoteVideo.onplay = () => {
                            log('Remote video playing');
                        };
                        
                        remoteVideo.onerror = (e) => {
                            log(`Remote video error: ${e}`);
                        };
                    } else {
                        log('WARNING: Received track but no streams array');
                    }
                };
                
                // Handle ICE candidates with detailed logging
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        // Log detailed info about the candidate
                        const candidateInfo = event.candidate.candidate || 'unknown';
                        log(`ICE candidate: ${candidateInfo}`);
                        
                        // Check if this is a TURN relay candidate
                        if (candidateInfo.indexOf('relay') > -1) {
                            log('✅ TURN relay candidate found - TURN server working properly!');
                        }
                        
                        socket.emit('iceCandidate', {
                            to: targetIdInput.value,
                            candidate: event.candidate
                        });
                    } else {
                        log('ICE candidate gathering complete');
                    }
                };
                
                // Add ICE gathering state change handler
                peerConnection.onicegatheringstatechange = () => {
                    log(`ICE gathering state: ${peerConnection.iceGatheringState}`);
                };
                
                // Handle connection state changes with more detailed diagnostics
                peerConnection.oniceconnectionstatechange = () => {
                    const state = peerConnection.iceConnectionState;
                    log(`ICE connection state changed to: ${state}`);
                    
                    switch (state) {
                        case 'connected':
                            log('✅ ICE connection established successfully');
                            callStatusEl.textContent = 'Connected';
                            break;
                        case 'checking':
                            log('⌛ ICE connection checking - validating candidates...');
                            break;
                        case 'failed':
                            log('❌ ICE connection failed - could not establish connection');
                            log('This typically happens when TURN server authentication fails');
                            log('Verify TURN credentials match between server and client');
                            endCall();
                            break;
                        case 'disconnected':
                            log('⚠ ICE connection lost - attempting to recover...');
                            break;
                        case 'closed':
                            log('ICE connection closed');
                            break;
                    }
                };
                
                // Add signaling state change handler
                peerConnection.onsignalingstatechange = () => {
                    log(`Signaling state changed to: ${peerConnection.signalingState}`);
                };
                
                // Add connection state change handler
                peerConnection.onconnectionstatechange = () => {
                    log(`Connection state changed to: ${peerConnection.connectionState}`);
                    
                    if (peerConnection.connectionState === 'connected') {
                        log('✅ Peer connection fully established!');
                    }
                };
                
                return true;
            } catch (error) {
                log(`Media error: ${error.message}`);
                alert(`Could not access camera or microphone: ${error.message}`);
                return false;
            }
        }

        async function startCall() {
            const targetId = targetIdInput.value;
            
            if (!targetId) {
                alert('Please enter a target device ID');
                return;
            }
            
            log(`Starting call to: ${targetId}`);
            callStatusEl.textContent = 'Calling...';
            callButton.style.display = 'none';
            endButton.style.display = 'block';
            isInCall = true;
            
            try {
                const success = await setupPeerConnection();
                
                if (!success) {
                    endCall();
                    return;
                }
                
                // Create offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                // Send offer to signaling server
                socket.emit('makeCall', {
                    to: targetId,
                    offer: peerConnection.localDescription
                });
            } catch (error) {
                log(`Error starting call: ${error.message}`);
                endCall();
                alert('Failed to start call');
            }
        }

        async function answerCall(data) {
            log(`Answering call from: ${data.from}`);
            targetIdInput.value = data.from;
            callStatusEl.textContent = 'Answering...';
            callButton.style.display = 'none';
            endButton.style.display = 'block';
            isInCall = true;
            
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                
                // Create answer
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                // Send answer to signaling server
                socket.emit('answerCall', {
                    to: data.from,
                    answer: peerConnection.localDescription
                });
                
                callStatusEl.textContent = 'Connected';
            } catch (error) {
                log(`Error answering call: ${error.message}`);
                endCall();
                alert('Failed to answer call');
            }
        }

        function endCall() {
            log('Ending call');
            callStatusEl.textContent = 'Idle';
            callButton.style.display = 'block';
            endButton.style.display = 'none';
            isInCall = false;
            
            // Send end call signal if in a call
            if (targetIdInput.value && isConnected) {
                socket.emit('endCall', { to: targetIdInput.value });
            }
            
            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            // Stop local stream
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    log(`Stopping local track: ${track.kind}`);
                    track.stop();
                });
                localStream = null;
                localVideo.srcObject = null;
            }
            
            // Clear remote stream
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => {
                    log(`Stopping remote track: ${track.kind}`);
                    track.stop();
                });
                remoteStream = null;
                remoteVideo.srcObject = null;
            } else {
                log('No remote stream to clean up');
                remoteVideo.srcObject = null;
            }
        }

        // Initialize
        log('Web tester initialized');
        callStatusEl.textContent = 'Idle';
        updateDeviceId(); // Set initial device ID based on role
    </script>
</body>
</html>
